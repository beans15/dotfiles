" NeoBundleでの管理を行う
" 一時的にファイルタイプを無効に
filetype off

if g:portable
  " NeoBundleへのパスを追加
  set rtp+=$VIM/vimfiles/bundle/neobundle.vim/
  " NeoBundleを初期化
  call neobundle#rc($VIM.'/vimfiles/bundle')
else
  set rtp+=~/.vim/bundle/neobundle.vim/
  call neobundle#rc(expand('~/.vim/bundle'))
endif


" プラグインのロード
let s:meet_neocomplete_requirements = has('lua') && (v:version > 703 || (v:version == 703 && has('patch885')))

" 汎用的なもの
NeoBundle 'Shougo/vimproc', {
  \ 'build': {
  \     'windows': 'echo "Sorry, cannot update vimproc binary file in Windows."',
  \     'cygwin': 'make -f make_cygwin.mak',
  \     'mac': 'make -f make_mac.mak',
  \     'unix': 'make -f make_unix.mak',
  \   },
  \ }
NeoBundle 'itchyny/lightline.vim'
NeoBundle 'surround.vim'
NeoBundle 'unite.vim'
NeoBundleLazy 'h1mesuke/unite-outline', {'autoload': {'unite_sources': ['outline']}}
NeoBundleLazy 'sgur/unite-qf', {'autoload': {'unite_sources': ['qf']}}
NeoBundleLazy 'tsukkee/unite-help', {'autoload': {'unite_sources': ['help']}}
NeoBundleLazy 'tsukkee/unite-tag', {'autoload': {'unite_sources': ['tag']}}
NeoBundle 'Shougo/vimfiler'
NeoBundle 'deton/jasegment.vim'
NeoBundle 'kana/vim-textobj-user'
NeoBundle 'kana/vim-textobj-indent'
NeoBundle 'kana/vim-smartinput'
NeoBundle 'Align'

" 開発用
if s:meet_neocomplete_requirements
  NeoBundle 'Shougo/neocomplete.vim'
  NeoBundleFetch 'Shougo/neocomplcache.vim'
else
  NeoBundleFetch 'Shougo/neocomplete.vim'
  NeoBundle 'Shougo/neocomplcache.vim'
endif

NeoBundle 'Shougo/neosnippet'
NeoBundle 'quickrun'
NeoBundle 'thinca/vim-ref'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'tpope/vim-fugitive'
NeoBundleLazy 'Shougo/vimshell', {'autoload': {'commands': ['VimShell']}}

" 特定言語の開発用
NeoBundleLazy 'vim-coffee-script', {'autoload': {'filetypes': ['coffee']}}
NeoBundleLazy 'mattn/emmet-vim', {'autoload': {'filetypes': ['html', 'css', 'scss', 'php']}}
NeoBundleLazy 'kana/vim-filetype-haskell', {'autoload': {'filetypes': ['haskell']}}
NeoBundleLazy 'ujihisa/neco-ghc', {'autoload': {'filetypes': ['haskell']}}

" その他
NeoBundle 'mattn/webapi-vim'
NeoBundleLazy 'mattn/gist-vim', {'autoload': {'commands': ['Gist']}}
NeoBundleLazy 'sudo.vim', {'autoload': {'commands': ['SudoRead', 'SudoWrite']}}

" カラースキーム
NeoBundle 'w0ng/vim-hybrid'
NeoBundle 'nanotech/jellybeans.vim'
"NeoBundle 'jonathanfilip/vim-lucius'
"NeoBundle 'tomasr/molokai'
"NeoBundle 'jpo/vim-railscasts-theme'
"NeoBundle 'vim-scripts/Wombat'
"NeoBundle 'vim-scripts/twilight'
NeoBundle 'altercation/vim-colors-solarized'

NeoBundleLazy 'beans15/vim-latex', {'autoload': {'filetypes': ['tex']}}

NeoBundle 'thinca/vim-localrc'


"==================
" neocomplete
"==================

if s:meet_neocomplete_requirements
  let g:neocomplete#enable_at_startup = 1
  let g:neocomplete#enable_smart_case = 1
  let g:neocomplete#enable_auto_select = 0

  "if !exists('g:neocomplete#force_omni_input_patterns')
  "  let g:neocomplete#force_omni_input_patterns = {}
  "endif

  "let g:neocomplete#force_omni_input_patterns.python = '\h\w*\|[^. \t]\.\w*'

  if g:portable
    let g:neocomplete#data_directory = expand("$VIM/.neocomplete")
  endif
else
  " 起動時に有効にする
  let g:neocomplcache_enable_at_startup = 1
  " 大文字小文字が混じっている場合は、大文字小文字を区別する
  let g:neocomplcache_enable_smart_case = 1
  " キーワードの最小長さを3文字に
  let g:neocomplcache_min_syntax_length = 3
  " 補完候補の先頭を選択状態に
  "let g:neocomplcache_enable_auto_select = 1

  if g:portable
    let g:neocomplcache_temporary_dir = expand("$VIM/.neocomplcache")
  endif
endif

"==================
" neosnippet
"==================

" スニペットのディレクトリを指定
if g:portable
  let g:neosnippet#snippets_directory = expand("$VIM/vimfiles/snippets")
else
  let g:neosnippet#snippets_directory = expand('~/.vim/snippets')
endif
" スニペット補完のキーバインド
imap <silent><C-l> <Plug>(neosnippet_expand_or_jump)
smap <silent><C-l> <Plug>(neosnippet_expand_or_jump)

let g:neosnippet#enable_snipmate_compatibility = 1


"==================
" unite
"==================

" インサートモードで開始
let g:unite_enable_start_insert = 1
let g:unite_force_overwrite_statusline = 0

"imap <silent> <C-k>  <Plug>(neocomplcache_start_unite_complete)
nnoremap [unite] <Nop>
nmap     <Leader>u [unite]
nmap     <Space>u [unite]
nnoremap <silent> [unite]f :<C-u>UniteWithBufferDir -buffer-name=files file file/new directory/new<CR>
nnoremap <silent> [unite]u :<C-u>Unite -buffer-name=files file_mru buffer<CR>
nnoremap <silent> [unite]a :<C-u>Unite -buffer-name=files file buffer file_mru file/new<CR>
nnoremap <silent> [unite]b :<C-u>Unite -buffer-name=files bookmark<CR>
nnoremap <silent> [unite]t :<C-u>Unite -immediately tab:no-current<CR>
nnoremap <silent> [unite]r :<C-u>Unite -buffer-name=register -no-start-insert register<CR>
nnoremap <silent> [unite]/ :<C-u>Unite -winheight=10 -auto-highlight line<CR>
nnoremap <silent> [unite]* :<C-u>UniteWithCursorWord -no-start-insert -winheight=10 -auto-highlight line<CR>
nnoremap <silent> [unite]s :<C-u>Unite -no-start-insert source<CR>
nnoremap <silent> [unite]p :<C-u>call <SID>unite_project()<CR>
nnoremap <silent> [unite]o :<C-u>Unite -no-quit -vertical -no-start-insert -direction=rightbelow -winwidth=30 outline<CR>
nnoremap <silent> [unite]] :<C-u>UniteWithCursorWord -no-start-insert -winheight=10 tag<CR>

function! s:unite_project(...)
  let opts = (a:0 ? join(a:000, ' ') : '')
  let dir = unite#util#path2project_directory(expand('%'))

  execute 'Unite '.opts.' file_rec:'.dir
endfunction

augroup UniteFileType
  autocmd!
  "autocmd FileType vim      nnoremap <silent><buffer> K :<C-u>UniteWithCursorWord help<CR>
  autocmd FileType sh       nnoremap <silent><buffer> K :<C-u>UniteWithCursorWord -default-action=right ref/man<CR>
  autocmd FileType python   nnoremap <silent><buffer> K :<C-u>UniteWithCursorWord -default-action=right ref/pydoc<CR>
  autocmd FileType ruby     nnoremap <silent><buffer> K :<C-u>UniteWithCursorWord -default-action=right ref/refe<CR>
augroup END

call unite#custom_source('file_rec', 'filters', ['matcher_fuzzy', 'sorter_default', 'converter_default'])

" unite-grepのバックエンドをagに変更
if executable('ag')
  let g:unite_source_grep_command = 'ag'
  let g:unite_source_grep_default_opts = '--nocolor --nogroup'
  let g:unite_source_grep_recursive_opt = ''
  let g:unite_source_grep_max_candidates = 200
endif

if g:portable
  let g:unite_data_directory = expand("$VIM/.unite")
endif

"==================
" vimfiler
"==================

" セーフモードを無効にする
let g:vimfiler_safe_mode_by_default = 0
let g:vimfiler_force_overwrite_statusline = 0
let g:vimfiler_as_default_explorer = 1

nnoremap <silent> <Leader>Ex :<C-u>VimFilerBufferDir -simple -explorer -winwidth=30<CR>
nnoremap <silent> <Leader>Tex :<C-u>call <SID>vimfiler_tab_bufferdir()<CR>

function! s:vimfiler_tab_bufferdir()
  exec 'VimFilerTab -simple ' . expand('%:p:h')
endfunction

if g:portable
  let g:vimfiler_data_directory = expand("$VIM/.vimfiler")
endif

"==================
" vimshell
"==================

let g:vimshell_force_overwrite_statusline = 0

"==================
" vim-coffee-script
"==================

" 無名関数でラップしない
let g:coffee_make_options = '-b'

"==================
" syntastic
"==================
let g:syntastic_mode_map = {
  \ 'mode':               'passive',
  \ 'active_filetypes':   [],
  \ 'passive_filetypes':  [] }

nnoremap <silent> <Leader>L :<C-u>SyntasticCheck<CR>

"==================
" smartinput
"==================
call smartinput#map_to_trigger('i', '<Space>', '<Space>', '<Space>')

call smartinput#define_rule({
  \ 'at': '(\%#)',
  \ 'char': '<Space>',
  \ 'input': '<Space><Space><Left>',
  \ })

call smartinput#define_rule({
  \ 'at': '{\%#}',
  \ 'char': '<Space>',
  \ 'input': '<Space><Space><Left>',
  \ })

call smartinput#define_rule({
  \ 'at': '\[\%#\]',
  \ 'char': '<Space>',
  \ 'input': '<Space><Space><Left>',
  \ })

call smartinput#define_rule({
  \ 'at': '( \%# )',
  \ 'char': '<BS>',
  \ 'input': '<Del><BS>',
  \ })

call smartinput#define_rule({
  \ 'at': '{ \%# }',
  \ 'char': '<BS>',
  \ 'input': '<Del><BS>',
  \ })

call smartinput#define_rule({
  \ 'at': '\[ \%# \]',
  \ 'char': '<BS>',
  \ 'input': '<Del><BS>',
  \ })

" タグの間で改行した時に空行を作る
call smartinput#define_rule({
  \ 'at': '<\(\w\+\)\( .*\)\?>\%#<\/\1>',
  \ 'char': '<Enter>',
  \ 'input': '<Enter><C-O>O'
  \ })

" vimの辞書定義で自動的にバックスラッシュを入れる
call smartinput#define_rule({
  \ 'at': '^ *\\ *.*\%#$',
  \ 'char': '<Enter>',
  \ 'input': '<Enter><Bslash>',
  \ 'filetype': ['vim'],
  \ })

call smartinput#define_rule({
  \ 'at': '^ *function!\?.*\%#$',
  \ 'char': '<Enter>',
  \ 'input': '<Enter>endfunction<C-O>O',
  \ 'filetype': ['vim'],
  \ })

call smartinput#define_rule({
  \ 'at': '^ *if.*\%#$',
  \ 'char': '<Enter>',
  \ 'input': '<Enter>endif<C-O>O',
  \ 'filetype': ['vim'],
  \ })

"==================
" lightline
"==================

" リロードしたときにエラーが出るのを防ぐ
if !exists('g:lightline')
  let g:lightline = {
    \ 'colorscheme':  'wombat',
    \ 'active': {
    \   'left': [ [ 'mode', 'paste' ],
    \             [ 'fugitive', 'readonly', 'filename', 'modified' ] ],
    \ },
    \ 'component': {
    \   'readonly': '%{&readonly?"⭤":""}',
    \   'modified': '%{&modified?"+":&modifiable?"":"-"""}',
    \ },
    \ 'component_function': {
    \   'mode': 'MyMode',
    \   'fugitive': 'MyFugitive',
    \   'fileformat': 'MyFileFormat',
    \   'filetype': 'MyFiletype',
    \   'fileencoding': 'MyFileencoding',
    \   'filename': 'MyFilename',
    \ },
    \ 'component_visible_condition': {
    \   'readonly': '&readonly',
    \   'modified': '(&modified||!&modifiable)',
    \ },
    \ }
endif

function! MyMode()
  return  &ft == 'unite' ? 'Unite' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! MyFilename()
  let filetype_mapping = {
    \ 'vimfiler': 'vimfiler#get_status_string()',
    \ 'unite': 'unite#get_status_string()',
    \ 'vimshell': "substitute(b:vimshell.current_dir, expand('~'), '~', '')",
    \ }

  if has_key(filetype_mapping, &ft)
    return eval(filetype_mapping[&ft])
  else
    return expand('%:t') != '' ? expand('%:t') : '[No Name]'
  endif
endfunction

function! MyFugitive()
  return exists('*fugitive#head') && len(fugitive#head()) ? '⭠ '.fugitive#head() : ''
endfunction

function! MyFiletype()
  return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth('.') > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyFileFormat()
  return winwidth('.') > 70 ? &fileformat : ''
endfunction

"==================
" vim-ref
"==================

if g:portable
  let g:ref_cache_dir = expand("$VIM/.vim_ref_cache")
endif

"======================
" オレオレセッティング
"======================

if filereadable(expand('~/.vimrc.plugin.mine'))
  source ~/.vimrc.plugin.mine
endif

" ファイルタイプを有効にする
filetype plugin indent on

NeoBundleCheck
